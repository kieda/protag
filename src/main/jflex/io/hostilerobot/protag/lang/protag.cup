package io.hostilerobot.protag.lang;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.SymbolFactory;
import io.hostilerobot.protag.lang.ProtagLexer;
import io.hostilerobot.protag.lang.ProtagSymbol;
import io.hostilerobot.protag.lang.ProtagSymbolFactory;
import io.hostilerobot.protag.lang.ProtagTokenType;
import io.hostilerobot.protag.lang.ast.*;
import io.hostilerobot.protag.lang.ast.impl.*;
import io.hostilerobot.protag.meta.*;
import io.hostilerobot.protag.meta.ProtagMetaTable.ProtagMetaBuilder;

parser code {:
    ProtagMetaTable metaTable;
    ProtagLexer lexer;
    ProtagSymbolFactory symbolFactory;
    ProtagParser(ProtagLexer lex, ProtagSymbolFactory sf) {
        super(lex, sf);
        this.metaTable = new ProtagMetaTable();
        this.lexer = lex;
        this.symbolFactory = sf;
    }
:}
action code {:
//    ASTMetaInfoFactory<ProtagMetaInfo> factory = metaTable.getFactory();

    public void addComments(ProtagMetaBuilder meta, List<LProtagLineComment> comments) {

        for(LProtagLineComment comment : comments) {
//            comment.setParent(parent);
            meta.addComment(comment);
        }
    }

:}
init with {: lexer.reset(); :}
scan with {: ProtagSymbol s =  lexer.next_token(); System.out.println("INCOMING: " + s); return s; :}

// special tokens
/*terminal JPATH_START, FPATH_START,
    DOT, SLASH, PLUS, MINUS, AND, PROPERTY_SEP,
    MAP_START, MAP_END, LIST_SEP, LIST_START, LIST_END, PRECEDENCE_START, PRECEDENCE_END,
    PAIR_SEP, TRANSITION_SEP_L, TRANSITION_SEP_R;*/
terminal DOT, PLUS, MINUS;

// string tokens
/*terminal CharSequence COMMENT, WHITESPACE, REGEX, LITERAL, JNAME, JBODY, FNAME, NATURAL, PNAME, PBODY; */
terminal CharSequence COMMENT, WHITESPACE;
terminal Integer NATURAL;

// leaf nodes
/*non terminal LFileName FileName;
non terminal LJavaBody JavaBody;
non terminal LProtagBody ProtagBody; */
non terminal LProtagInteger ProtagInteger;
/*non terminal LProtagLiteral ProtagLiteral;
non terminal LProtagName ProtagName;
non terminal LProtagNatural ProtagNatural;
non terminal LProtagQuotient ProtagQuotient; */
non terminal LProtagReal ProtagReal;
non terminal LProtagLineComment ProtagComment;
//non terminal LProtagWhitespace ProtagWhitespace;
// composite nodes
/*non terminal IFilePath FilePath;
non terminal IFilePathSegment FilePathSegment;
non terminal IProtagList ProtagList;
non terminal IProtagMap ProtagMap;
non terminal IProtagPair ProtagPair;
non terminal IProtagPath ProtagPath;
non terminal IProtagPathSegment ProtagPathSegment;
non terminal IProtagPrecedence ProtagPrecedence;
non terminal IProtagProperties ProtagProperties;
non terminal IProtagRegex ProtagRegex;
non terminal IProtagSequence ProtagSequence;
non terminal IProtagTransitionLeft ProtagTransitionLeft;
non terminal IProtagTransitionRight ProtagTransitionRight; */

// internal nodes
non terminal IProtagSequence protag, program;//, protag_;
non terminal ProtagNode _item,
    _unboundedData, _baseData
    ;
non terminal EOF;
//    jScope, jScopeSegment, jSegmentSingle, jSegmentMulti, jSegmentInclJBody, jSegmentExclJBody;
non terminal ESignType _sign;
non terminal XDecimal _decimal;
non terminal LinkedList<LProtagLineComment> spacing;
/**
 * protag may have items that consist of a header, then a set of properties
 * # example
 *   headerItem
 *   headerItem2
 *   123
 *   properties:
 *   properties2:
 *  // goes to the end of file
 */

start with program;

/*protag ::= protag_:seq
    {: RESULT = seq; :}
    | // protag_ or empty
    {:
        RESULT = new ProtagSequence();
        factory.createInfo(RESULT, currentSymbol());
    :}
    ;*/
program ::= protag:val {: RESULT = val; :}
    | EOF
    {:
        RESULT = new ProtagSequence();
    :};
protag ::=
//ProtagProperties|
    _item:i protag:rest
    {:
        if(i == null) {
            RESULT = rest;
        } else if(rest == null){
            RESULT = new ProtagSequence();
            i.setParent(RESULT);
        } else {
            rest.getItems().addFirst(i);
            RESULT = rest;
            i.setParent(RESULT);
        }
    :}
    | _item:item
    {:
        if(item == null) {
            RESULT = null;
        } else {
            RESULT = new ProtagSequence();
            item.setParent(RESULT);
            RESULT.getItems().addFirst(item);
        }
    :}
    ;
//    _unboundedData:data protag:protag1
//    {:
//        data.setParent(protag1);
//        protag1.getItems().addFirst(data);
//        RESULT = protag1;
//    :}
//    WHITESPACE protag:protag
//    {: RESULT = protag; :}
//    ProtagComment:comment protag:protag2
//    {:
//        comment.setParent(protag2);
//        metaTable.getInfo(protag2)
//            .getComments().addFirst(comment);
//        RESULT = protag2;
//    :}
//    |
////    {:
////        RESULT = new ProtagSequence();
////        factory.createInfo(RESULT, currentSymbol());
////    :}
//
//    |ProtagComment:comment
//    {:
//        RESULT = new ProtagSequence();
//        comment.setParent(RESULT);
//        var meta = factory.createInfo(seq, currentSymbol());
//        meta.getComments().addFirst(comment);
//    :}
//    |WHITESPACE
//    {:
//        RESULT = new ProtagSequence();
//        var meta = factory.createInfo(seq, currentSymbol());
//    :}
//    |_unboundedData:item
//    {:
////        Deque<ProtagNode> initial = new LinkedList<>();
////        initial.addFirst(item);
//        ProtagSequence seq = new ProtagSequence();//, initial);
//        seq.getItems().addFirst(item);
//        item.setParent(seq);
//        factory.createInfo(seq, currentSymbol());
//
//        RESULT = seq;
//    :}

_item ::=
    _unboundedData:data {:RESULT = data;:}
    // commentsection
    |ProtagComment:comment {:RESULT = comment;:}
    |WHITESPACE {:RESULT = null;:};

_baseData ::=
//    yPath1|jPath|fPath // paths. final path is a two part or more protag segment
//    |ySegmentMulti  // single protag segment (not a path)
//    |Precedence // (x)
//    |Map|List|   // composite data
    ProtagReal:real
    {:
        RESULT = real;
        // todo - set comments of real, integer's parents to real
        metaTable.getBuilder(real).build(
            symbolFactory.lookup("ProtagReal", real)
        );
    :}
//    |QUOTIENT
    |ProtagInteger:integer
    {:
        RESULT = integer;
        metaTable.getBuilder(integer).build(
            symbolFactory.lookup("ProtagInteger", integer)
        );
    :}  // primitive - numbers
//    |REGEX|LITERAL|YNAME // primitive - string types
    ;
/*
// # Java Paths and Scopes
// `[a-z]`0`[a-z]`1       x0y1
// "asdf"0"asdf"`[a-z]`   asdf0asdfx
// asdf"asdf"0`[a-z]`     asdfasdf0x
// asdf"asdf"0abc         asdfasdf0abc
// 1                      <invalid>
// 0"asdf"                <invalid>
// 0`[1-9]`               <invalid>
    jPath ::= JPATH_START spacing jScope;
    jScope ::= jScopeSegment spacing DOT spacing jScope
        | jScopeSegment;

    jScopeSegment ::= jSegmentMulti
        | jSegmentSingle;
    // single item in the segment
    jSegmentSingle ::= JNAME
        | containedSegment;
    // multiple items in the segment
    jSegmentMulti ::=
        JNAME jSegmentExclJBody
        | containedSegment jSegmentInclJBody;
    // jBody or jName cannot show up twice in a row
    jSegmentInclJBody ::=
        JBODY jSegmentExclJBody
        | JBODY
        | jSegmentExclJBody;
    jSegmentExclJBody ::= containedSegment jSegmentInclJBody
        | containedSegment;

// # file paths and scopes
    fPath ::= FPATH_START spacing fScope;
    fScope ::= fScopeSegment spacing SLASH spacing fScope
        | fScopeSegment;

    fScopeSegment ::= fSegmentMulti
        | fSegmentSingle;
    fSegmentSingle ::= FNAME
        | containedSegment;
    fSegmentMulti ::= containedSegment fSegmentInclFName
        | FNAME fSegmentExclFName;
    fSegmentExclFName ::= containedSegment fSegmentInclFName
        | containedSegment;
    fSegmentInclFName ::= FNAME fSegmentExclFName
        | FNAME
        | fSegmentExclFName;

// # protag paths and scopes
    yPath1 ::= NATURAL spacing DOT spacing ySegmentExclNat spacing DOT spacing yPathRest
        | NATURAL spacing DOT spacing ySegmentExclNat
        | ySegmentExclNat spacing DOT spacing yPathRest;

    ySegmentExclNat ::= ySegmentMulti
        | containedSegment
        | YNAME;  // multi segments are not considered nats

    yPathRest ::= _yPathItem spacing DOT spacing yPathRest
        |  _yPathItem;

    ySegmentMulti ::= containedSegment ySegmentInclVals
        | _yNameOrNat ySegmentExclVals;

    _yPathItem ::= ySegmentMulti
        | containedSegment
        | _yNameOrNat;
    _yNameOrNat ::= YNAME
        | NATURAL;

    // (55).`~*5` vs 55.`~*5`
    // x.0abc x.0`[1-3]` x.0"123"
    // NATURAL -> containedSegment
    // (yBody|yName) -> containedSegment
    // containedSegment -> YBODY|NATURAL|containedSegment
    ySegmentExclVals ::= containedSegment ySegmentInclVals
        | containedSegment;
    ySegmentInclVals ::= _yBodyOrNat ySegmentExclVals
        | _yBodyOrNat
        | ySegmentExclVals;

    _yBodyOrNat ::= NATURAL
        | YBODY;
    // disallow NATURAL.NATURAL
    // -1.0.123
*/
// possible -
/// connect any number of paths using "asdf"+(123, 456).0+"abc"
// current -
// connect paths by not having whitespace
/**
 * y = [1, 2, 3, 4]
 * y`k v~k<`(y.len.`~/2`)
 * y"asdf" + (123).0 +
 * TODO - custom regex specifically for integers and indices
 * DFA for processing integers
 */

//QUOTIENT ::= INTEGER spacing AND spacing INTEGER spacing SLASH spacing NATURAL
//    |  INTEGER spacing SLASH spacing NATURAL; // 1 & 3/4, -1 &3/4, +1 & -3/4, 1/2
ProtagInteger ::= _sign:sign spacing:c NATURAL:nat
    {:
        RESULT = new LProtagInteger(sign.negate(nat));
        var builder = metaTable.createBuilder(RESULT);
        addComments(builder, c);
        System.out.println(metaTable);
    :}
    | NATURAL:nat
    {:
        RESULT = new LProtagInteger(nat);
        metaTable.createBuilder(RESULT);
        System.out.println(metaTable);
    :};

ProtagReal ::= _sign:sign spacing:c _decimal:decimal
    {:
        RESULT = new LProtagReal(decimal.toDouble(sign));
        var builder = metaTable.createBuilder(RESULT);
        addComments(builder, c);
        System.out.println(metaTable);
    :}
    | _decimal:decimal
    {:
        RESULT = new LProtagReal(decimal.toDouble(ESignType.NONE));
        metaTable.createBuilder(RESULT);
        System.out.println(metaTable);
    :}
    ;

//ProtagNatural ::= NATURAL:nat {: RESULT = new LProtagNatural(null, nat); :};

// define DECIMAL in parser rather than lexer, as this might be part of a ysegment rather than a decimal
_decimal ::= NATURAL:integerPart DOT NATURAL:decimalPart
    {: RESULT = new XDecimal(integerPart, decimalPart); :}
    ;
_sign ::= PLUS {: RESULT = ESignType.PLUS; :}
    | MINUS {: RESULT = ESignType.MINUS; :};

// properties is just
//     name1 : value1a value1b
//     name2 : value2a value2b value2c
// to nest properties, we use precedence
//     name1 : value1a value1b
//     (name2 : value2a value2b) value2c
/*
Properties ::= _baseData spacing PROPERTY_SEP protag_
    | _baseData spacing PROPERTY_SEP;

Map ::= MAP_START spacing MAP_END // {}
    | MAP_START spacing MapItems spacing MAP_END;
//    // { a = b[, c = d]* }
MapItems ::= PairBounded spacing LIST_SEP spacing MapItems
    | PairBounded;

List ::= LIST_START spacing LIST_END // []
//    // [a[, b]*]
    | LIST_START spacing ListItems spacing LIST_END;
ListItems ::= BoundedData spacing LIST_SEP spacing ListItems
    | BoundedData;

Precedence ::= PRECEDENCE_START spacing BoundedData spacing PRECEDENCE_END;

PairExpr ::= _unboundedTransitionL spacing PAIR_SEP spacing _unboundedData;
TransitionLExpr ::= _unboundedTransitionR spacing TRANSITION_SEP_L spacing _unboundedTransitionL;
TransitionRExpr ::= _baseData spacing TRANSITION_SEP_R spacing _unboundedTransitionR;
*/
_unboundedData ::= //PairExpr|TransitionLExpr|TransitionRExpr|
    _baseData:base {: RESULT = base; :};
/*
_unboundedTransitionL ::= TransitionLExpr|_unboundedTransitionR;
_unboundedTransitionR ::= TransitionRExpr|_baseData;

PairBounded ::= _unboundedTransitionL spacing PAIR_SEP spacing BoundedData;
TransitionLBounded ::= _unboundedTransitionR spacing TRANSITION_SEP_L spacing _boundedTransitionL;
TransitionRBounded ::= _baseData spacing TRANSITION_SEP_R spacing _boundedTransitionR;
BoundedData ::= PairBounded|_boundedTransitionL;
_boundedTransitionL ::= TransitionLBounded|_boundedTransitionR;
_boundedTransitionR ::= TransitionRBounded|Properties|_baseData;

// all these items that can be contained in a path and have incipient and terminator chars.
containedSegment ::= REGEX|LITERAL|List|Map|Precedence;
// asdf10&3/4 vs "asdf"10 & 3/4"asdf"
// spacing items
*/
// todo : spacing is a linked list
// todo : remove ProtagWhitespace rule
// todo : utility to add
spacing ::=
    WHITESPACE spacing:prev
    {: RESULT = prev; :}
    | ProtagComment:comment spacing:prev
    {:
        if(prev == null) {
            RESULT = new LinkedList<>();
        } else {
            RESULT = prev;
        }
        RESULT.addFirst(comment);
    :}
    | // empty
    {: RESULT = null; :} // don't create a list if we don't need to
    ;
//    (WHITESPACE|COMMENT)*
ProtagComment ::= COMMENT:comment
    {: RESULT = new LProtagLineComment(comment); :};