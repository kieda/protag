package io.hostilerobot.protag.lang;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.SymbolFactory;
import io.hostilerobot.protag.lang.ProtagLexer;
import io.hostilerobot.protag.lang.ProtagSymbol;
import io.hostilerobot.protag.lang.ProtagSymbolFactory;
import io.hostilerobot.protag.lang.ProtagTokenType;
import io.hostilerobot.protag.lang.ast.*;
import io.hostilerobot.protag.lang.ast.impl.*;

parser code {:
    ProtagLexer lexer;
    ProtagSymbolFactory symbolFactory;
    ProtagParser(ProtagLexer lex, ProtagSymbolFactory sf) {
        super(lex, sf);
        this.lexer = lex;
        this.symbolFactory = sf;
    }
:}
init with {: lexer.reset(); :}
scan with {: return lexer.next_token(); :}

// special tokens
/*terminal JPATH_START, FPATH_START,
    DOT, SLASH, PLUS, MINUS, AND, PROPERTY_SEP,
    MAP_START, MAP_END, LIST_SEP, LIST_START, LIST_END, PRECEDENCE_START, PRECEDENCE_END,
    PAIR_SEP, TRANSITION_SEP_L, TRANSITION_SEP_R;*/
terminal DOT, PLUS, MINUS;

// string tokens
/*terminal CharSequence COMMENT, WHITESPACE, REGEX, LITERAL, JNAME, JBODY, FNAME, NATURAL, PNAME, PBODY; */
terminal CharSequence COMMENT, WHITESPACE;
terminal Integer NATURAL;

// leaf nodes
/*non terminal LFileName FileName;
non terminal LJavaBody JavaBody;
non terminal LProtagBody ProtagBody; */
non terminal LProtagInteger ProtagInteger;
/*non terminal LProtagLiteral ProtagLiteral;
non terminal LProtagName ProtagName;
non terminal LProtagNatural ProtagNatural;
non terminal LProtagQuotient ProtagQuotient; */
non terminal LProtagReal ProtagReal;
non terminal LProtagLineComment ProtagComment;
non terminal LProtagWhitespace ProtagWhitespace;
// composite nodes
/*non terminal IFilePath FilePath;
non terminal IFilePathSegment FilePathSegment;
non terminal IProtagList ProtagList;
non terminal IProtagMap ProtagMap;
non terminal IProtagPair ProtagPair;
non terminal IProtagPath ProtagPath;
non terminal IProtagPathSegment ProtagPathSegment;
non terminal IProtagPrecedence ProtagPrecedence;
non terminal IProtagProperties ProtagProperties;
non terminal IProtagRegex ProtagRegex;
non terminal IProtagSequence ProtagSequence;
non terminal IProtagTransitionLeft ProtagTransitionLeft;
non terminal IProtagTransitionRight ProtagTransitionRight; */

// internal nodes
non terminal IProtagSequence protag, protag_;
non terminal ProtagNode _item, _unboundedData, _baseData
    ;
//    jScope, jScopeSegment, jSegmentSingle, jSegmentMulti, jSegmentInclJBody, jSegmentExclJBody;
non terminal ESignType _sign;
non terminal XDecimal _decimal;
non terminal spacing;
/**
 * protag may have items that consist of a header, then a set of properties
 * # example
 *   headerItem
 *   headerItem2
 *   123
 *   properties:
 *   properties2:
 *  // goes to the end of file
 */

start with protag;

protag ::= protag_:seq
    {: RESULT = seq; :}
    | // protag_ or empty
    {: RESULT = new ProtagSequence(null, new LinkedList<ProtagNode>()); :}
    ;
protag_ ::= //ProtagProperties|
    _item:item protag_:protag
    {:
//        item.setParent(protag);
        protag.getItems().addFirst(item);
        RESULT = protag;
    :}
    |_item:item
    {:
        Deque<ProtagNode> initial = new LinkedList<>();
        initial.addFirst(item);
        ProtagSequence seq = new ProtagSequence(null, initial);
//        item.setParent(seq);
        RESULT = seq;
    :};
_item ::=
    _unboundedData:data {:RESULT = data;:}
    // commentsection
    |ProtagComment:comment {:RESULT = comment;:}
    |ProtagWhitespace:whitespace {: RESULT = whitespace;:};

_baseData ::=
//    yPath1|jPath|fPath // paths. final path is a two part or more protag segment
//    |ySegmentMulti  // single protag segment (not a path)
//    |Precedence // (x)
//    |Map|List|   // composite data
    ProtagReal:real {: RESULT = real; :}
//    |QUOTIENT
    |ProtagInteger:integer {: RESULT = integer; :}  // primitive - numbers
//    |REGEX|LITERAL|YNAME // primitive - string types
    ;
/*
// # Java Paths and Scopes
// `[a-z]`0`[a-z]`1       x0y1
// "asdf"0"asdf"`[a-z]`   asdf0asdfx
// asdf"asdf"0`[a-z]`     asdfasdf0x
// asdf"asdf"0abc         asdfasdf0abc
// 1                      <invalid>
// 0"asdf"                <invalid>
// 0`[1-9]`               <invalid>
    jPath ::= JPATH_START spacing jScope;
    jScope ::= jScopeSegment spacing DOT spacing jScope
        | jScopeSegment;

    jScopeSegment ::= jSegmentMulti
        | jSegmentSingle;
    // single item in the segment
    jSegmentSingle ::= JNAME
        | containedSegment;
    // multiple items in the segment
    jSegmentMulti ::=
        JNAME jSegmentExclJBody
        | containedSegment jSegmentInclJBody;
    // jBody or jName cannot show up twice in a row
    jSegmentInclJBody ::=
        JBODY jSegmentExclJBody
        | JBODY
        | jSegmentExclJBody;
    jSegmentExclJBody ::= containedSegment jSegmentInclJBody
        | containedSegment;

// # file paths and scopes
    fPath ::= FPATH_START spacing fScope;
    fScope ::= fScopeSegment spacing SLASH spacing fScope
        | fScopeSegment;

    fScopeSegment ::= fSegmentMulti
        | fSegmentSingle;
    fSegmentSingle ::= FNAME
        | containedSegment;
    fSegmentMulti ::= containedSegment fSegmentInclFName
        | FNAME fSegmentExclFName;
    fSegmentExclFName ::= containedSegment fSegmentInclFName
        | containedSegment;
    fSegmentInclFName ::= FNAME fSegmentExclFName
        | FNAME
        | fSegmentExclFName;

// # protag paths and scopes
    yPath1 ::= NATURAL spacing DOT spacing ySegmentExclNat spacing DOT spacing yPathRest
        | NATURAL spacing DOT spacing ySegmentExclNat
        | ySegmentExclNat spacing DOT spacing yPathRest;

    ySegmentExclNat ::= ySegmentMulti
        | containedSegment
        | YNAME;  // multi segments are not considered nats

    yPathRest ::= _yPathItem spacing DOT spacing yPathRest
        |  _yPathItem;

    ySegmentMulti ::= containedSegment ySegmentInclVals
        | _yNameOrNat ySegmentExclVals;

    _yPathItem ::= ySegmentMulti
        | containedSegment
        | _yNameOrNat;
    _yNameOrNat ::= YNAME
        | NATURAL;

    // (55).`~*5` vs 55.`~*5`
    // x.0abc x.0`[1-3]` x.0"123"
    // NATURAL -> containedSegment
    // (yBody|yName) -> containedSegment
    // containedSegment -> YBODY|NATURAL|containedSegment
    ySegmentExclVals ::= containedSegment ySegmentInclVals
        | containedSegment;
    ySegmentInclVals ::= _yBodyOrNat ySegmentExclVals
        | _yBodyOrNat
        | ySegmentExclVals;

    _yBodyOrNat ::= NATURAL
        | YBODY;
    // disallow NATURAL.NATURAL
    // -1.0.123
*/
// possible -
/// connect any number of paths using "asdf"+(123, 456).0+"abc"
// current -
// connect paths by not having whitespace
/**
 * y = [1, 2, 3, 4]
 * y`k v~k<`(y.len.`~/2`)
 * y"asdf" + (123).0 +
 * TODO - custom regex specifically for integers and indices
 * DFA for processing integers
 */

//QUOTIENT ::= INTEGER spacing AND spacing INTEGER spacing SLASH spacing NATURAL
//    |  INTEGER spacing SLASH spacing NATURAL; // 1 & 3/4, -1 &3/4, +1 & -3/4, 1/2
ProtagInteger ::= _sign:sign spacing NATURAL:nat
    {: RESULT = new LProtagInteger(sign.negate(nat)); :}
    | NATURAL:nat
    {: RESULT = new LProtagInteger(nat); :};

ProtagReal ::= _sign:sign spacing _decimal:decimal
    {: RESULT = new LProtagReal(null, decimal.toDouble(sign)); :}
    | _decimal:decimal
    {: RESULT = new LProtagReal(null, decimal.toDouble(ESignType.NONE)); :}
    ;

//ProtagNatural ::= NATURAL:nat {: RESULT = new LProtagNatural(null, nat); :};

// define DECIMAL in parser rather than lexer, as this might be part of a ysegment rather than a decimal
_decimal ::= NATURAL:integerPart DOT NATURAL:decimalPart
    {: RESULT = new XDecimal(integerPart, decimalPart); :}
    ;
_sign ::= PLUS {: RESULT = ESignType.PLUS; :}
    | MINUS {: RESULT = ESignType.MINUS; :};

// properties is just
//     name1 : value1a value1b
//     name2 : value2a value2b value2c
// to nest properties, we use precedence
//     name1 : value1a value1b
//     (name2 : value2a value2b) value2c
/*
Properties ::= _baseData spacing PROPERTY_SEP protag_
    | _baseData spacing PROPERTY_SEP;

Map ::= MAP_START spacing MAP_END // {}
    | MAP_START spacing MapItems spacing MAP_END;
//    // { a = b[, c = d]* }
MapItems ::= PairBounded spacing LIST_SEP spacing MapItems
    | PairBounded;

List ::= LIST_START spacing LIST_END // []
//    // [a[, b]*]
    | LIST_START spacing ListItems spacing LIST_END;
ListItems ::= BoundedData spacing LIST_SEP spacing ListItems
    | BoundedData;

Precedence ::= PRECEDENCE_START spacing BoundedData spacing PRECEDENCE_END;

PairExpr ::= _unboundedTransitionL spacing PAIR_SEP spacing _unboundedData;
TransitionLExpr ::= _unboundedTransitionR spacing TRANSITION_SEP_L spacing _unboundedTransitionL;
TransitionRExpr ::= _baseData spacing TRANSITION_SEP_R spacing _unboundedTransitionR;
*/
_unboundedData ::= //PairExpr|TransitionLExpr|TransitionRExpr|
    _baseData:base {: RESULT = base; :};
/*
_unboundedTransitionL ::= TransitionLExpr|_unboundedTransitionR;
_unboundedTransitionR ::= TransitionRExpr|_baseData;

PairBounded ::= _unboundedTransitionL spacing PAIR_SEP spacing BoundedData;
TransitionLBounded ::= _unboundedTransitionR spacing TRANSITION_SEP_L spacing _boundedTransitionL;
TransitionRBounded ::= _baseData spacing TRANSITION_SEP_R spacing _boundedTransitionR;
BoundedData ::= PairBounded|_boundedTransitionL;
_boundedTransitionL ::= TransitionLBounded|_boundedTransitionR;
_boundedTransitionR ::= TransitionRBounded|Properties|_baseData;

// all these items that can be contained in a path and have incipient and terminator chars.
containedSegment ::= REGEX|LITERAL|List|Map|Precedence;
// asdf10&3/4 vs "asdf"10 & 3/4"asdf"
// spacing items
*/
spacing ::=
    WHITESPACE spacing
    | COMMENT spacing
    | // empty
    ;
//    (WHITESPACE|COMMENT)*
ProtagWhitespace ::= WHITESPACE:whitespace
    {: RESULT = new LProtagWhitespace(null, whitespace); :};
ProtagComment ::= COMMENT:comment
    {: RESULT = new LProtagLineComment(null, comment); :};